<!DOCTYPE html>
<html>
    <head>
        <title>D3 - Data Driven Drivel</title>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.16/d3.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
        <link rel="stylesheet" type="text/css" href="./styles.css">
    </head>
    <body>
        <div id="chartArea"></div>
        <script type="text/javascript">
            var dataset = _.map(_.range(35), i => Math.random() * 35);

            var margin = {top: 15, right: 15, bottom: 35, left: 50};
            var w = 400 - margin.left - margin.right,
                h = 300 - margin.top - margin.bottom;

            var svg = d3.select('#chartArea').append('svg')
                .attr('width', w + margin.left + margin.right)
                .attr('height', h + margin.top + margin.bottom)
                .style('border', '2px dashed black')
                .append('g')
                .attr('transform', `translate(${margin.left}, ${margin.top})`)

            var xScale = d3.scale.ordinal()
                .domain(dataset)
                .rangeBands([0, w], 0.2, /*.5*/); //second argument is the padding between each band (bar); it can feasibly range from 0 (none) to 1 (too much). A measurement of .5 means that the padding between bands is the same width as the bands themselves. Third argument is padding at the beginning and end of the set of bands (beginning and end of 'x scale' of graph). So it gives a little space between where your "chart" begins and where the bars will actually start showing up.

            var yScale = d3.scale.linear()
                .domain([0, d3.max(dataset)] /* * 1.1*/) //Setting this to slightly more than the dataset (by using the 1.1 multiplier) gives us a little bit of space between the highest bar and the top of the "chart".
                .range([h, 0])

            // var colorScale = d3.scale.linear()  //we've copied the yScale (because we still want a linear ... distribution(?)),
            //     .domain([0, d3.max(dataset)])  //but have removed the 1.02 multiplier because we don't need a buffer anymore
            //     //.domain([0, dataset.length]) //for when you want the range to move across the number of bars
            //     .range(['lightgreen', 'teal']); //then we can add a starting and ending color. Woot.

            // var colorScale = d3.scale.quantile()  //divides the amount of data into chunks, but I honestly am pretty confused about how when I use anything besides a single number in the domain,
            //     .domain([22]) //22 of the bars of the chart will be the first color listed
            //     .range(['lightgreen', 'teal', 'purple']); //the rest of the bars will be the last color listed.

            var colorScale = d3.scale.quantize()  //divides the amount of data into evenly-sized "buckets",
                .domain([0, dataset.length])
                .range(['lightgreen', 'chartreuse', 'teal', 'purple']); //this, for example creates four even color "chunks".

            svg.selectAll('rect')
                .data(dataset)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('x', (d) => xScale(d))
                .attr('y', (d) => h - yScale(d))
                .attr('width', xScale.rangeBand())
                .attr('height', (d) => yScale(d))
                // .attr('fill', colorScale) //this is the exact same thing as (d) => colorScale(d). D3 just assumes that much.
                .attr('fill', (d, i) => colorScale(i)) //this colors bars based on their position in the array
        </script>
    </body>
</html>